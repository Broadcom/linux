/*
 * Copyright 2016 Broadcom
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License, version 2, as
 * published by the Free Software Foundation (the "GPL").
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License version 2 (GPLv2) for more details.
 *
 * You should have received a copy of the GNU General Public License
 * version 2 (GPLv2) along with this source code.
 */

/*
 * This driver implements the Broadcom DTE Digital Timing Engine Driver (DTE).
 * The DTE allows for hardware time stamping of network packets, audio/video
 * samples and/or GPIO inputs in a common adjustable time base.
 *
 * The DTE creates timestamps of hardware based events such as GPIO, I2S
 * signals for audio, etc. It provides a clock for 802.1AS / NCO timestamps for
 * network packets. It has up to 32 "clients" -- the hardware inputs into the
 * timestamping engine.
 *
 * Clients can be enabled at any time with timestamps being generated at varying
 * frequencies. As clients are enabled that generate timestamps at higher
 * frequencies, the isochronous interrupt rate must be increased so that
 * overflows in the the h/w and s/w FIFO's don't occur.
 *
 * The DTE timestamper creates timestamps based on the current clock time. When
 * an event on an input occurs, DTE stores the timestamp in a h/w FIFO. Each
 * client has a divider that can be set to control the rate that timestamps are
 * generated at by the timestamper which are adjustable at run time.
 *
 * The isochronous interrupt is used to pull the timestamps out of the h/w
 * FIFO and store them in s/w FIFO's until they are pulled out of that from
 * user space. Each client has it's own FIFO allowing user space and kernel
 * consumers to only get timestamps they are interested in.
 *
 * The kernel API provided enables clients to get timestamps using
 * dte_enable_timestamp(). A clients divider is set with
 * dte_set_client_divider(). The isochronous interrupt frequency - the rate at
 * which the ISR fires to pull timestamps from h/w to s/w FIFO is
 * dte_set_irq_interval().
 *
 * Timestamps generated by the timestamper for clients are polled for using
 * dte_get_timestamp().
 *
 * The clock is controlled with the remaining functions: dte_set_time(),
 * dte_get_time(), dte_adj_time(), dte_adj_freq(). These functions provide
 * the time base for the timestamper but also provide a clock that was
 * meant to be used later by an Ethernet driver for NCO.
 *
 * ioctls are defined in uapi/linux/bcm_iproc_dte.h for the user space API and
 * correspond to these kernel functions.
 */

#include <linux/hw_random.h>
#include <linux/init.h>
#include <linux/io.h>
#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/slab.h>
#include <linux/of_address.h>
#include <linux/of_platform.h>
#include <linux/platform_device.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/printk.h>
#include <linux/delay.h>
#include <linux/kfifo.h>
#include <linux/interrupt.h>
#include <linux/uaccess.h>
#include <linux/bcm_iproc_dte.h>
#include <uapi/linux/bcm_dte.h>

#define DTE_SW_FIFO_SIZE                         64
#define DTE_HW_FIFO_SIZE                         16
#define DTE_MAX_DEVS                             1
#define DTE_DEVICE_NAME                          "dte"
#define DTE_DEFAULT_INTERVAL                     500000000

/* Registers */
#define DTE_CTRL_REG_BASE                        0x600
#define DTE_CTRL_REG__INTERRUPT                  16
#define DTE_NEXT_SOI_REG_BASE                    0x610
#define DTE_ILEN_REG_BASE                        0x614
#define DTE_LTS_FIFO_REG_BASE                    0x640
#define DTE_LTS_CSR_REG_BASE                     0x644
#define DTE_LTS_CSR_REG__FIFO_EMPTY              4
#define DTE_LTS_CSR_REG__FIFO_OVERFLOW           3
#define DTE_LTS_CSR_REG__FIFO_UNDERFLOW          2
#define DTE_NCO_LOW_TIME_REG_BASE                0x650
#define DTE_NCO_TIME_REG_BASE                    0x654
#define DTE_NCO_OVERFLOW_REG_BASE                0x658
#define DTE_NCO_INC_REG_BASE                     0x65c
#define DTE_LTS_DIV_54_REG_BASE                  0x660
#define DTE_LTS_DIV_76_REG_BASE                  0x664
#define DTE_LTS_DIV_98_REG_BASE                  0x668
#define DTE_LTS_DIV_1110_REG_BASE                0x66c
#define DTE_LTS_DIV_1312_REG_BASE                0x670
#define DTE_LTS_DIV_14_REG_BASE                  0x674
#define DTE_LTS_DIV_MASK                         0xffff
#define DTE_LTS_SRC_EN_REG_BASE                  0x680
#define DTE_INTR_STATUS_REG                      0x6A0
#define DTE_INTR_STATUS_ISO_INTR_SHIFT           0
#define DTE_INTR_STATUS_ISO_INTR_MASK            0x1
#define DTE_INTR_STATUS_FIFO_LEVEL_INTR_SHIFT    1
#define DTE_INTR_STATUS_FIFO_LEVEL_INTR_MASK     0x7
#define DTE_INTR_STATUS_TIMEOUT_INTR_SHIFT       4
#define DTE_INTR_STATUS_TIMEOUT_INTR_MASK        0x1
#define DTE_INTR_MASK_REG                        0x6A4
#define ISO_INTR_MASK_SHIFT                      0

#define NCO_FREQ_ABS_MAX_ADJ_PPB                 50000000
#define DTE_FLOW_ERROR_MASK                      0xc
/*
 * There are 3 time registers in the DTE block;
 * NCO_OVERFLOW[7:0] (sum3)
 * NCO_TIME[31:0] (sum2)
 * NCO_LOW_TIME[31:0] (sum1).
 * These can be considered as a 72 bit overall timestamp[71:0]
 * in ns with a format of 44.28
 *
 * The DTE block runs at 125MHz, ie; every 8ns,
 * NCO_INC is added to the timestamp[71:0].
 * NCO_INC represents fractional ns in 4.28 format.
 *
 * The DTE client Timstamps have a resoultion of ns and is constructed
 * from the 28 LS bits of sum2 and 4 MS bits of sum1.
 *
 * Register            |     sum3    |          sum2     |         sum1       |
 *                     |7           0|31  28            0|31    28:27        0|
 * Timestamp[71:0]     |71                                      28:27        0|
 * NCO_INC[31:0]                                         |31    28:27        0|
 * DTE client TS[31:0]                    |31                  0|
 */

/* NCO nominal increment = 8ns DTE operates at 125 MHz */
#define NCO_INC_NOMINAL 0x80000000

static const struct bcm_iproc_dte_params iproc_dte_params = {
	.lts_reg_offset = 0x660,
	.divider_size = 2, /* in bytes. */
	.lts_start_index = 4,
	.num_of_clients = 11,
};

static irqreturn_t bcm_iproc_dte_isr_threaded(int irq, void *drv_ctx);

static void bcm_iproc_dte_enable(struct bcm_dte *iproc_dte, bool enable)
{
	int intr_mask;

	intr_mask = readl(iproc_dte->audioeav + DTE_INTR_MASK_REG);
	if (enable)
		/* enable isochronous interrupt */
		intr_mask &= ~BIT(ISO_INTR_MASK_SHIFT);
	else
		/* disable isochronous interrupt */
		intr_mask |= BIT(ISO_INTR_MASK_SHIFT);

	writel(intr_mask, iproc_dte->audioeav + DTE_INTR_MASK_REG);
}

static int dte_enable_timestamp(struct bcm_dte *iproc_dte,
				unsigned int client, bool enable)
{
	int src_ena;

	if (!iproc_dte)
		return -EINVAL;

	if (client >= iproc_dte->num_of_clients)
		return -EINVAL;

	spin_lock(&iproc_dte->lock);

	src_ena = readl(iproc_dte->audioeav +
		DTE_LTS_SRC_EN_REG_BASE);
	if (enable)
		src_ena |= BIT(iproc_dte->dte_cli[client].lts_index);
	else
		src_ena &= ~BIT(iproc_dte->dte_cli[client].lts_index);

	writel(src_ena,
		iproc_dte->audioeav + DTE_LTS_SRC_EN_REG_BASE);

	spin_unlock(&iproc_dte->lock);

	return 0;
}

static int dte_set_client_divider(struct bcm_dte *iproc_dte,
				  unsigned int client,
				  uint32_t divider)
{
	int lts_div;

	if (!iproc_dte)
		return -EINVAL;

	if (client >= iproc_dte->num_of_clients)
		return -EINVAL;

	/* Divider not supported for Divider 15 (Client 11) */
	if (client == 11)
		return 0;

	/* Check for maximum divider size */
	if (divider > DTE_LTS_DIV_MASK)
		return -EINVAL;

	spin_lock(&iproc_dte->lock);

	lts_div = readl(iproc_dte->audioeav +
			iproc_dte->dte_cli[client].reg_offset);
	lts_div &= ~(DTE_LTS_DIV_MASK << iproc_dte->dte_cli[client].shift);
	lts_div |= (divider << iproc_dte->dte_cli[client].shift);
	writel(lts_div, iproc_dte->audioeav +
		iproc_dte->dte_cli[client].reg_offset);

	spin_unlock(&iproc_dte->lock);

	return 0;
}

static void dte_hw_fifo_tmr(unsigned long data)
{
	struct platform_device *pdev = (struct platform_device *)data;
	struct bcm_dte *iproc_dte;

	iproc_dte = (struct bcm_dte *)platform_get_drvdata(pdev);
	bcm_iproc_dte_isr_threaded(0, (void *)data);

	/* reset timer */
	mod_timer(&iproc_dte->fifo_timer, (jiffies +
		nsecs_to_jiffies((iproc_dte->irq_interval_ns))));
}

static int dte_set_irq_interval(struct bcm_dte *iproc_dte,
	uint32_t nanosec)
{
	int next_soi;
	int current_time;

	if (!iproc_dte)
		return -EINVAL;

	if (iproc_dte->irq < 0) {
		/* if IIG irq is not specified run the soft-timer mode */
		if (!nanosec)
			del_timer_sync(&iproc_dte->fifo_timer);
		else {
			init_timer(&iproc_dte->fifo_timer);
			iproc_dte->fifo_timer.function = dte_hw_fifo_tmr;
			iproc_dte->fifo_timer.data =
				(unsigned long)iproc_dte->pdev;
			iproc_dte->fifo_timer.expires =
				jiffies + nsecs_to_jiffies((nanosec));
			add_timer(&iproc_dte->fifo_timer);
		}

		return 0;
	}

	spin_lock(&iproc_dte->lock);

	/*
	 * To ensure proper operation of the isochronous time interval
	 * generation (ITG) timing pulse requires programming of
	 * 1) Next Start of Interrupt Time (ns) (NEXT_SOI)
	 * 2) Interval Length (ns) (ILEN)
	 * The block first compares the value of the NEXT_SOI with
	 * that of the 29-bit value of time DTE_NCO_TIME_REG_BASE
	 * that has been left-shifted by 4 or multiplied by 16 for
	 * generating the first interrupt.  Thereafter upon completion
	 * of every ILEN number of nano-seconds it generates an ITG
	 * interrupt and the NEXT_SOI register is auto-incremented by ILEN
	 */

	/* Get the current time (sum2) (units of 16ns) */
	current_time = readl(iproc_dte->audioeav + DTE_NCO_TIME_REG_BASE);

	/*
	 * Set the Start of Next Interval (units of ns) to trigger on next
	 * interval
	 */
	next_soi = (current_time << 4) + (nanosec);
	writel(next_soi, iproc_dte->audioeav + DTE_NEXT_SOI_REG_BASE);

	/* configure interval length (units of ns) */
	writel(nanosec, iproc_dte->audioeav + DTE_ILEN_REG_BASE);

	if (nanosec)
		/* enable isochronous interrupt */
		bcm_iproc_dte_enable(iproc_dte, true);
	else
		/* disable isochronous interrupt */
		bcm_iproc_dte_enable(iproc_dte, false);

	spin_unlock(&iproc_dte->lock);

	if (!nanosec)
		/* make sure the interrupt handler isn't running */
		synchronize_irq(iproc_dte->irq);

	return 0;
}

static int dte_get_timestamp(struct bcm_dte *iproc_dte,
			     unsigned int client, struct timespec *ts)
{

	if (!iproc_dte)
		return -EINVAL;

	if (client >= iproc_dte->num_of_clients)
		return -EINVAL;

	if (kfifo_out(
		&iproc_dte->recv_fifo[client],
		ts, sizeof(struct timespec)) == 0)
		return -EPERM;

	return 0;
}

static int dte_set_time(struct bcm_dte *iproc_dte, struct timespec *ts)
{
	if (!iproc_dte)
		return -EINVAL;

	spin_lock(&iproc_dte->lock);

	/* Disable NCO Increment */
	writel(0, iproc_dte->audioeav + DTE_NCO_INC_REG_BASE);

	/* Reset Timers */
	writel(0, iproc_dte->audioeav + DTE_NCO_LOW_TIME_REG_BASE);
	writel(0, iproc_dte->audioeav + DTE_NCO_TIME_REG_BASE);
	writel(0, iproc_dte->audioeav + DTE_NCO_OVERFLOW_REG_BASE);

	/* Initialize last overflow value to track wrap condition */
	iproc_dte->timestamp_overflow_last = 0;

	/* Initialize Reference timespec */
	iproc_dte->ts_ref = *ts;

	/* re-enable nco increment */
	writel(NCO_INC_NOMINAL, iproc_dte->audioeav + DTE_NCO_INC_REG_BASE);

	spin_unlock(&iproc_dte->lock);

	return 0;
}

static int dte_get_time(struct bcm_dte *iproc_dte,
			struct timespec *ts)
{
	uint32_t current_time_sum1;
	uint32_t current_time_sum2;
	uint32_t current_time_sum3;
	uint32_t timestamp_overflow;
	uint64_t ns;

	if (!iproc_dte)
		return -EINVAL;

	spin_lock(&iproc_dte->lock);

	/* Read Timers */
	current_time_sum1 = readl(iproc_dte->audioeav +
				DTE_NCO_LOW_TIME_REG_BASE);
	current_time_sum2 = readl(iproc_dte->audioeav +
				DTE_NCO_TIME_REG_BASE);
	current_time_sum3 = readl(iproc_dte->audioeav +
				DTE_NCO_OVERFLOW_REG_BASE);

	/*
	 * Register            |  sum3 |  sum2  | sum1     |
	 *                     |7     0|31 28  0|31 28:27 0|
	 * Timestamp[71:0]     |71                  28:27 0|
	 */

	/* Current time in units of ns */
	ns = (((uint64_t)(current_time_sum3 & 0xff) << 36) |
		((uint64_t)current_time_sum2 << 4) |
		(uint64_t)((current_time_sum1 >> 28) & 0xf));

	/*
	 * Determined if wraparound has occurred
	 * Timestamp overflow only includes the bottom 8 bits of sum3
	 * and the top 4 bits of sum2
	 * Units of 2^32 ns = 4.294967296 sec
	 */
	timestamp_overflow = (ns >> 32) & 0xfff;
	if (timestamp_overflow < iproc_dte->timestamp_overflow_last)
		/*
		 * Wrap around has occurred but not yet reflected in
		 * the reference timespec
		 * Full wrap around amount is 44bits in ns
		 * Precisely 17592.186044416 sec = ~4.887 hrs
		 */
		ns += (uint64_t)0x1<<44;

	/* Convert current timestamp(ns) to timespec */
	*ts = ns_to_timespec(ns);

	/* Add the current time to the reference time */
	*ts = timespec_add(iproc_dte->ts_ref, *ts);

	spin_unlock(&iproc_dte->lock);

	return 0;
}

static int dte_adj_time(struct bcm_dte *iproc_dte, int64_t delta)
{
	struct timespec ts_delta;

	if (!iproc_dte)
		return -EINVAL;

	ts_delta = ns_to_timespec(delta);

	spin_lock(&iproc_dte->lock);

	/* Update Reference timespec */
	iproc_dte->ts_ref = timespec_add(iproc_dte->ts_ref, ts_delta);

	spin_unlock(&iproc_dte->lock);

	return 0;
}

static int dte_adj_freq(struct bcm_dte *iproc_dte, int32_t ppb)
{
	uint32_t nco_incr;

	if (!iproc_dte)
		return -EINVAL;

	if (abs(ppb) > NCO_FREQ_ABS_MAX_ADJ_PPB) {
		dev_info(&iproc_dte->pdev->dev,
			"freq ppb adj too big\n");
		return 0;
	}

	/* 125MHz with 3.29 reg cfg */
	if (ppb < 0)
		nco_incr = NCO_INC_NOMINAL -
			(u32)(div64_u64((((u64)abs(ppb) * BIT(28)) +
				62500000ULL), 125000000ULL));
	else
		nco_incr = NCO_INC_NOMINAL +
			(u32)(div64_u64((((u64)abs(ppb) * BIT(28)) +
				62500000ULL), 125000000ULL));

	spin_lock(&iproc_dte->lock);

	/* Update NCO Increment */
	writel(nco_incr, iproc_dte->audioeav + DTE_NCO_INC_REG_BASE);

	spin_unlock(&iproc_dte->lock);

	return 0;
}

static void dte_update_user(struct bcm_dte *iproc_dte,
	unsigned int client,
	struct file *fp,
	bool add)
{
	if (add) {
		if (fp)
			iproc_dte->user[client].fp = fp;
		else
			iproc_dte->user[client].internal_user = true;

		iproc_dte->usr_cnt++;
	} else {
		iproc_dte->user[client].fp = NULL;
		iproc_dte->user[client].internal_user = false;
		iproc_dte->usr_cnt--;
	}
}

static void dte_disable_all_clients(struct bcm_dte *iproc_dte)
{
	int i;

	/* Disable all clients */
	for (i = 0; i < iproc_dte->num_of_clients; i++) {
		dte_enable_timestamp(iproc_dte, i, false);
		dte_set_client_divider(iproc_dte, i, 0);
	}

	dte_set_irq_interval(iproc_dte, 0);

	memset(&iproc_dte->user, 0, sizeof(struct dte_user_info));
	iproc_dte->usr_cnt = 0;
}

static int dte_enable_ts(struct bcm_dte *iproc_dte,
			 unsigned int client,
			 bool enable,
			 uint32_t divider,
			 struct file *fp)
{
	int rc = 0;

	if ((!iproc_dte) || (client >= iproc_dte->num_of_clients))
		return -EINVAL;

	mutex_lock(&iproc_dte->en_ts_lock);

	if (enable) {
		/* check if client is in use */
		if ((iproc_dte->user[client].fp) ||
			(iproc_dte->user[client].internal_user)) {
			rc = -EBUSY;
			goto en_ts_unlock_exit;
		}

		if (!iproc_dte->usr_cnt) {
			/*
			 * IRQ Interval needs to be set only
			 * once (when enabling first client)
			 */
			rc = dte_set_irq_interval(iproc_dte,
					iproc_dte->irq_interval_ns);
			if (rc) {
				dev_err(&iproc_dte->pdev->dev,
					"Failed to set IRQ interval\n");
				goto en_ts_unlock_exit;
			}
		}

		/* clear the clients fifo */
		kfifo_reset(&iproc_dte->recv_fifo[client]);

		rc = dte_set_client_divider(iproc_dte, client, divider);
		if (rc)
			goto dte_ts_disable_irq;

		rc = dte_enable_timestamp(iproc_dte, client, enable);
		if (rc) {
			goto dte_ts_disable_divider;
		} else {
			/* Add client */
			dte_update_user(iproc_dte, client, fp, enable);
			goto en_ts_unlock_exit;
		}
	} else {
		if ((iproc_dte->user[client].fp) ||
			(iproc_dte->user[client].internal_user)) {
			dte_update_user(iproc_dte, client, fp, false);
		} else {
			/* Client is already disabled */
			rc = -EINVAL;
			goto en_ts_unlock_exit;
		}
	}

dte_ts_disable_divider:
	/* Check if anyone is using the client */
	rc |= dte_enable_timestamp(iproc_dte, client, false);
	rc |= dte_set_client_divider(iproc_dte, client, 0);

dte_ts_disable_irq:
	/* Disable DTE irq if there are no more users */
	if (!iproc_dte->usr_cnt)
		rc |= dte_set_irq_interval(iproc_dte, 0);

en_ts_unlock_exit:
	mutex_unlock(&iproc_dte->en_ts_lock);

	return rc;
}

static int dte_open(struct inode *pnode, struct file *fp)
{
	/* look up device info for this device file */
	struct bcm_dte *iproc_dte = container_of(pnode->i_cdev,
			struct bcm_dte, dte_cdev);

	fp->private_data = iproc_dte;

	return 0;
}

static void dte_display_drv_info(struct bcm_dte *iproc_dte)
{
	int i;
	uint32_t nco_incr;
	int32_t ppb;

	dev_info(&iproc_dte->pdev->dev,
		"DTE Driver: %s\n",
		iproc_dte->pdev->name);
	dev_info(&iproc_dte->pdev->dev,
		" Fifo Mode: %s, interval: %dns\n",
		((iproc_dte->irq > 0) ? "irq" : "soft-timer"),
		iproc_dte->irq_interval_ns);

	dev_info(&iproc_dte->pdev->dev,
		" hw fifo errors: uf=%d, of=%d\n",
		iproc_dte->fifouf,
		iproc_dte->fifoof);

	dev_info(&iproc_dte->pdev->dev,
		" Active Clients: %d\n",
		iproc_dte->usr_cnt);

	for (i = 0; i < iproc_dte->num_of_clients; i++) {
		if ((iproc_dte->user[i].fp) ||
			(iproc_dte->user[i].internal_user))
			dev_info(&iproc_dte->pdev->dev,
				"    %2d (%s)\n",
				i,
				((iproc_dte->user[i].internal_user) ?
					"kernel-drv" : "user-space"));
	}

	nco_incr = readl(iproc_dte->audioeav + DTE_NCO_INC_REG_BASE);
	/* Calculate the ppb adjustment from the NCO value*/
	if (nco_incr < NCO_INC_NOMINAL)
		ppb = -1 * (div64_u64(((u64)(NCO_INC_NOMINAL - nco_incr)
			* 125000000ULL) + 0x8000000, (u64)BIT(28)));
	else
		ppb =  div64_u64(((u64)(nco_incr - NCO_INC_NOMINAL)
			* 125000000ULL) + 0x8000000, (u64)BIT(28));

	dev_info(&iproc_dte->pdev->dev,
		" nco_inc_reg: 0x%x, ppb: %i\n",
		nco_incr,
		ppb);
}

static long dte_ioctl(struct file *filep,
		      unsigned int cmd,
		      unsigned long arg)
{
	int ret = 0;
	struct dte_client_data dte_client_info;
	struct dte_timestamp dte_timestamp;
	struct timespec ts;
	int64_t delta;
	int32_t ppb;
	struct bcm_dte *iproc_dte = filep->private_data;

	mutex_lock(&iproc_dte->mutex);
	switch (cmd) {
	case DTE_IOCTL_GET_TIMESTAMP:
		if (copy_from_user(&dte_timestamp, (struct dte_timestamp *)arg,
				sizeof(struct dte_timestamp))) {
			ret = -EACCES;
			goto err_out;
		}
		if (dte_get_timestamp(iproc_dte,
				dte_timestamp.client,
				&dte_timestamp.ts)) {
			ret = -EPERM;
			goto err_out;
		}
		if (copy_to_user((struct dte_timestamp *)arg, &dte_timestamp,
				sizeof(struct dte_timestamp)))
			ret = -EACCES;
		break;

	case DTE_IOCTL_SET_TIME:
		if (copy_from_user(&ts, (struct timespec *)arg,
				sizeof(struct timespec))) {
			ret = -EACCES;
			goto err_out;
		}
		if (dte_set_time(iproc_dte, &ts))
			ret = -EPERM;
		break;

	case DTE_IOCTL_GET_TIME:
		if (dte_get_time(iproc_dte, &ts))
			ret = -EPERM;
		if (copy_to_user((struct timespec *)arg, &ts,
				sizeof(struct timespec)))
			ret = -EACCES;
		break;

	case DTE_IOCTL_ADJ_TIME:
		if (copy_from_user(&delta, (int64_t *)arg,
				sizeof(int64_t))) {
			ret = -EACCES;
			goto err_out;
		}
		if (dte_adj_time(iproc_dte, delta))
			ret = -EPERM;
		break;

	case DTE_IOCTL_ADJ_FREQ:
		if (copy_from_user(&ppb, (int32_t *)arg,
				sizeof(int32_t))) {
			ret = -EACCES;
			goto err_out;
		}
		if (dte_adj_freq(iproc_dte, ppb))
			ret = -EPERM;
		break;

	case DTE_IOCTL_ENABLE_CLIENT_TS:
		if (copy_from_user(&dte_client_info,
				   (struct dte_client_data *)arg,
				   sizeof(struct dte_client_data))) {
			ret = -EACCES;
			goto err_out;
		}

		ret = dte_enable_ts(iproc_dte,
				    dte_client_info.client,
				    dte_client_info.enable,
				    dte_client_info.divider,
				    filep);
		break;

	case DTE_IOCTL_DISPLAY_DRV_INF:
		dte_display_drv_info(iproc_dte);
		break;

	default:
		ret = -EINVAL;
		break;
	}

err_out:
	mutex_unlock(&iproc_dte->mutex);
	return ret;
}

int dte_release(struct inode *node, struct file *fp)
{
	struct bcm_dte *iproc_dte = fp->private_data;
	int i = 0;

	for (i = 0; i < iproc_dte->num_of_clients; i++)
		if (iproc_dte->user[i].fp == fp)
			dte_enable_ts(iproc_dte, i, false, 0, fp);

	return 0;
}

static const struct file_operations dte_cdev_fops = {
	.open           = dte_open,
	.unlocked_ioctl = dte_ioctl,
	.release = dte_release,
};

static irqreturn_t bcm_iproc_dte_isr_threaded(int irq, void *drv_ctx)
{
	uint32_t fifo_csr;
	uint32_t rd_data;
	uint32_t current_time_sum2;
	uint32_t current_time_sum3;
	uint32_t i = 0;
	uint32_t active_clients;
	int client;
	int inlen;
	struct platform_device *pdev = (struct platform_device *)drv_ctx;
	struct bcm_dte *iproc_dte;
	uint32_t timestamp_overflow;
	uint32_t timestamp_ns;
	uint64_t ns;
	struct timespec ts_stamp;
	uint32_t status;

	iproc_dte = (struct bcm_dte *)platform_get_drvdata(pdev);

	/* clear interrupt bit */
	writel(1<<DTE_CTRL_REG__INTERRUPT,
		iproc_dte->audioeav + DTE_CTRL_REG_BASE);

	/* clear all interrupts in status register */
	status = (DTE_INTR_STATUS_ISO_INTR_MASK <<
		DTE_INTR_STATUS_ISO_INTR_SHIFT) |
		(DTE_INTR_STATUS_FIFO_LEVEL_INTR_MASK <<
		DTE_INTR_STATUS_FIFO_LEVEL_INTR_SHIFT) |
		(DTE_INTR_STATUS_TIMEOUT_INTR_MASK <<
		DTE_INTR_STATUS_TIMEOUT_INTR_SHIFT);
	writel(status, iproc_dte->audioeav + DTE_INTR_STATUS_REG);

	/* get data from dte fifo */
	do {
		fifo_csr = readl(iproc_dte->audioeav +
			DTE_LTS_CSR_REG_BASE);
		/* exit if fifo is empty */
		if (fifo_csr & BIT(DTE_LTS_CSR_REG__FIFO_EMPTY))
			break;

		spin_lock(&iproc_dte->lock);

		/* first event contains active clients */
		active_clients = readl(iproc_dte->audioeav +
			DTE_LTS_FIFO_REG_BASE);

		/* then timestamp */
		rd_data = readl(iproc_dte->audioeav +
			DTE_LTS_FIFO_REG_BASE);

		/* Save the actual timestamp */
		timestamp_ns = rd_data;

		/* Get the timestamp overflow counters */
		current_time_sum2 = readl(iproc_dte->audioeav +
			DTE_NCO_TIME_REG_BASE);
		current_time_sum3 = readl(iproc_dte->audioeav +
			DTE_NCO_OVERFLOW_REG_BASE);
		spin_unlock(&iproc_dte->lock);

		/*
		 * Timestamp overflow only includes the bottom
		 * 8 bits of sum3 and the top 4 bits of sum2.
		 *
		 * Combine sum3 and sum2 to the timestamp_overflow.
		 * Units of 2^32 ns = 4.294967296 sec
		 */
		timestamp_overflow =
			((current_time_sum3 & 0xff) << 4) |
			((current_time_sum2 >> 28) & 0xffffff);
		/*
		 * If the current time is less than the fifo timestamped time
		 * then wrap around must have occurred.
		 * Convert current_time_sum2 to ns before comparison
		 */
		if ((current_time_sum2 << 4) <= timestamp_ns) {
			if (timestamp_overflow > 0)
				/*
				 * Decrement the overflow counter since the fifo
				 * timestamp occurred before overflow counter
				 * had incremented
				 */
				timestamp_overflow--;
			else
				/*
				 * If the overflow counter is zero *and*
				 * the timestamp wrapped then the overflow
				 * counter also wrapped.
				 * Set to max value of 12 bits wide.
				 * sum3 (8 bits) and sum2 (top 4 bits)
				 */
				timestamp_overflow = 0xfff;
		}

		spin_lock(&iproc_dte->lock);
		/*
		 * Update reference timespec if wrap of the timestamp overflow
		 * occurred
		 */
		if (timestamp_overflow < iproc_dte->timestamp_overflow_last) {
			struct timespec ts_wrapamount;
			/*
			 * Wrap around occurred.
			 * Full wrap around amount is 44 bits in ns.
			 * Includes sum3 (8bits), sum2 (32 bits), sum1 (4 bits)
			 * Precisely 17592.186044416 sec = ~4.887 hrs
			 */
			ts_wrapamount = ns_to_timespec((uint64_t)0x1<<44);
			/* Increment the reference */
			iproc_dte->ts_ref =
				timespec_add(iproc_dte->ts_ref, ts_wrapamount);
		}
		/* Track the last timestamp overflow value */
		iproc_dte->timestamp_overflow_last = timestamp_overflow;

		/* Convert current timestamp(ns) to timespec */
		ns = ((uint64_t)timestamp_overflow << 32) +
			timestamp_ns;
		ts_stamp = ns_to_timespec(ns);

		/* Add the current time to the reference time */
		ts_stamp = timespec_add(iproc_dte->ts_ref, ts_stamp);
		spin_unlock(&iproc_dte->lock);

		/*
		 * The valid timestamp may be valid for more than one client
		 * Examine all the active clients and insert timestamp
		 * to the appropriate software fifo for each client asserted
		 * Clients[0:3] are unused.
		 * Shift down by 4 to zero index the first valid input client
		 */
		active_clients >>= 4;

		for_each_set_bit(client,
			(unsigned long *)&active_clients,
			iproc_dte->num_of_clients) {
			/* Insert full timestamps into software fifo */
			inlen = kfifo_in(
				&iproc_dte->recv_fifo[client],
				&ts_stamp,
				sizeof(struct timespec));

			if (inlen != sizeof(struct timespec)) {
				iproc_dte->kfifoof[client]++;
				dev_err(&iproc_dte->pdev->dev,
					"kfifoof[%d] = %d\n",
					client,
					iproc_dte->kfifoof[client]);
			}
		}
	} while (++i < DTE_HW_FIFO_SIZE); /* at most get FIFO size */

	if (fifo_csr & BIT(DTE_LTS_CSR_REG__FIFO_UNDERFLOW)) {
		iproc_dte->fifouf++;
		dev_err(&iproc_dte->pdev->dev,
			"fifouf = %d\n", iproc_dte->fifouf);
	}
	if (fifo_csr & BIT(DTE_LTS_CSR_REG__FIFO_OVERFLOW)) {
		iproc_dte->fifoof++;
		dev_err(&iproc_dte->pdev->dev,
			"fifoof =%d\n", iproc_dte->fifoof);
	}

	/* overflow/underflow error, reset fifo */
	if (fifo_csr & DTE_FLOW_ERROR_MASK) {
		writel(0, iproc_dte->audioeav + DTE_LTS_CSR_REG_BASE);
		dev_err(&iproc_dte->pdev->dev, "Resetting HW FIFO\n");
	}

	return IRQ_HANDLED;
}

static const struct of_device_id bcm_iproc_dte_of_match[] = {
	{ .compatible = "brcm,iproc-dte", },
	{},
};
MODULE_DEVICE_TABLE(of, bcm_iproc_dte_of_match);

static int bcm_iproc_dte_probe(struct platform_device *pdev)
{
	struct device *dev = &pdev->dev;
	struct resource *res;
	struct bcm_dte *iproc_dte;
	int ret = -ENOMEM;
	dev_t devt;
	struct device *retdev;
	struct class *dte_class;
	int client, divider, lts_reg_off;
	int irq;
	const struct bcm_iproc_dte_params *dte_params;

	if (of_device_is_compatible(dev->of_node, "brcm,iproc-dte"))
		dte_params = &iproc_dte_params;
	else {
		dev_err(&pdev->dev,
			"%s client map not defined\n", __func__);
		return -EINVAL;
	}

	iproc_dte = devm_kzalloc(dev, sizeof(*iproc_dte), GFP_KERNEL);
	if (!iproc_dte)
		return -ENOMEM;

	mutex_init(&iproc_dte->mutex);
	mutex_init(&iproc_dte->en_ts_lock);

	/* Audio DTE memory mapped registers */
	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
	iproc_dte->audioeav = devm_ioremap_resource(dev, res);
	if (IS_ERR(iproc_dte->audioeav)) {
		dev_err(&pdev->dev, "%s IO remap audioeav failed\n", __func__);
		return PTR_ERR(iproc_dte->audioeav);
	}

	spin_lock_init(&iproc_dte->lock);

	/* get interrupt */
	irq = platform_get_irq(pdev, 0);
	iproc_dte->irq = irq;
	if (irq < 0)
		dev_info(&pdev->dev, "irq not specified, running soft-timer mode\n");

	ret = of_property_read_u32(pdev->dev.of_node,
		"brcm,dte-interval-ns", &iproc_dte->irq_interval_ns);
	if (ret) {
		dev_info(&pdev->dev, "interval not specified, defaulting to %d\n",
			DTE_DEFAULT_INTERVAL);
		iproc_dte->irq_interval_ns = DTE_DEFAULT_INTERVAL;
	}

	if (irq > 0) {
		ret = devm_request_threaded_irq(&pdev->dev, irq,
					NULL, bcm_iproc_dte_isr_threaded,
					IRQF_ONESHOT, pdev->name, pdev);
		if (ret) {
			dev_err(&pdev->dev, "request_irq error %d\n", ret);
			return ret;
		}
	}

	iproc_dte->num_of_clients = dte_params->num_of_clients;

	iproc_dte->dte_cli = devm_kzalloc(dev,
			sizeof(struct dte_client_mapping) *
			iproc_dte->num_of_clients, GFP_KERNEL);
	if (!iproc_dte->dte_cli)
		return -ENOMEM;

	iproc_dte->recv_fifo = devm_kzalloc(dev,
				sizeof(struct kfifo) *
				iproc_dte->num_of_clients, GFP_KERNEL);
	if (!iproc_dte->recv_fifo)
		return -ENOMEM;

	iproc_dte->kfifoof = devm_kzalloc(dev,
				sizeof(uint32_t) *
				iproc_dte->num_of_clients, GFP_KERNEL);
	if (!iproc_dte->kfifoof)
		return -ENOMEM;

	iproc_dte->user = devm_kzalloc(dev,
				sizeof(struct dte_user_info) *
				iproc_dte->num_of_clients, GFP_KERNEL);
	if (!iproc_dte->user)
		return -ENOMEM;

	divider = sizeof(u32) / dte_params->divider_size;
	lts_reg_off = dte_params->lts_reg_offset;

	for (client = 0; client < iproc_dte->num_of_clients; client++) {
		iproc_dte->dte_cli[client].client_index = client;
		iproc_dte->dte_cli[client].lts_index =
			dte_params->lts_start_index + client;
		if (divider == client) {
			lts_reg_off += 4;
			divider += dte_params->divider_size;
		}
		if ((divider - dte_params->divider_size == client)
			|| (client == 0)) {
			iproc_dte->dte_cli[client].reg_offset =	lts_reg_off;
			iproc_dte->dte_cli[client].shift = 0;
		} else {
			iproc_dte->dte_cli[client].reg_offset = lts_reg_off;
			iproc_dte->dte_cli[client].shift =
				dte_params->divider_size * 8;
		}
	}

	for (client = 0; client < iproc_dte->num_of_clients; client++) {
		ret = kfifo_alloc(&iproc_dte->recv_fifo[client],
				DTE_SW_FIFO_SIZE * sizeof(struct timespec),
				GFP_KERNEL);
		if (ret) {
			dev_err(dev, "Failed kfifo alloc\n");
			goto err_free_kfifo;
		}
	}

	/* create device */
	cdev_init(&iproc_dte->dte_cdev, &dte_cdev_fops);

	iproc_dte->pdev = pdev;

	/* create class for mdev auto create node /dev/dte */
	dte_class = class_create(THIS_MODULE, DTE_DEVICE_NAME);
	if (IS_ERR(dte_class)) {
		ret = PTR_ERR(dte_class);
		dev_err(&pdev->dev, "can't register static dte class\n");
		goto err_free_kfifo;
	}
	iproc_dte->dte_class = dte_class;

	ret = alloc_chrdev_region(&devt, 0, DTE_MAX_DEVS, DTE_DEVICE_NAME);
	if (ret) {
		dev_err(&pdev->dev,
			"%s Alloc char device region failed\n", __func__);
		goto err_class_destroy;
	}

	ret = cdev_add(&iproc_dte->dte_cdev, devt, 1);
	if (ret) {
		dev_err(dev, "Failed adding dte cdev file\n");
		goto err_unreg_chardev;
	}

	retdev = device_create(iproc_dte->dte_class, NULL,
			devt, NULL, DTE_DEVICE_NAME);
	if (IS_ERR(retdev)) {
		dev_err(&pdev->dev, "can't create dte device\n ");
		ret = PTR_ERR(retdev);
		goto err_cdev_delete;
	}

	iproc_dte->enable_ts = dte_enable_ts;
	iproc_dte->get_ts = dte_get_timestamp;
	iproc_dte->nco_set_time = dte_set_time;
	iproc_dte->nco_get_time = dte_get_time;
	iproc_dte->nco_adj_time = dte_adj_time;
	iproc_dte->nco_adj_freq = dte_adj_freq;

	platform_set_drvdata(pdev, iproc_dte);
	iproc_dte->devt = devt;

	dev_info(dev, "DTE Initialized.\n");

	return 0;

err_cdev_delete:
	cdev_del(&iproc_dte->dte_cdev);
err_unreg_chardev:
	unregister_chrdev_region(devt, DTE_MAX_DEVS);
err_class_destroy:
	class_destroy(iproc_dte->dte_class);
err_free_kfifo:
	for (client = 0; client < iproc_dte->num_of_clients; client++)
		kfifo_free(&iproc_dte->recv_fifo[client]);
	return ret;
}

static int bcm_iproc_dte_remove(struct platform_device *pdev)
{
	int client;
	struct bcm_dte *iproc_dte = platform_get_drvdata(pdev);

	device_destroy(iproc_dte->dte_class, iproc_dte->devt);
	class_destroy(iproc_dte->dte_class);
	unregister_chrdev_region(iproc_dte->devt, DTE_MAX_DEVS);
	cdev_del(&iproc_dte->dte_cdev);

	/* Disable all clients */
	dte_disable_all_clients(iproc_dte);

	platform_set_drvdata(pdev, NULL);

	for (client = 0; client < iproc_dte->num_of_clients; client++)
		kfifo_free(&iproc_dte->recv_fifo[client]);

	return 0;
}

#ifdef CONFIG_PM_SLEEP
static int bcm_iproc_dte_suspend(struct device *dev)
{
	struct platform_device *pdev = to_platform_device(dev);
	struct bcm_dte *iproc_dte = platform_get_drvdata(pdev);

	dev_info(dev, "Suspending DTE driver\n");

	/* disable intr or timer */
	dte_set_irq_interval(iproc_dte, 0);

	/* Store and disable all sources */
	iproc_dte->src_ena = readl(
		iproc_dte->audioeav + DTE_LTS_SRC_EN_REG_BASE);
	writel(0, iproc_dte->audioeav + DTE_LTS_SRC_EN_REG_BASE);

	return 0;
}

static int bcm_iproc_dte_resume(struct device *dev)
{
	struct platform_device *pdev = to_platform_device(dev);
	struct bcm_dte *iproc_dte = platform_get_drvdata(pdev);

	dev_info(dev, "Resuming DTE driver\n");

	if (iproc_dte->usr_cnt) {
		/* re-enable intr or timer */
		dte_set_irq_interval(iproc_dte, iproc_dte->irq_interval_ns);

		/* Re-enable sources */
		writel(iproc_dte->src_ena,
			iproc_dte->audioeav + DTE_LTS_SRC_EN_REG_BASE);
	}

	return 0;
}

static const struct dev_pm_ops bcm_iproc_dte_pm_ops = {
	.suspend = bcm_iproc_dte_suspend,
	.resume = bcm_iproc_dte_resume
};

#define BCM_IPROC_DTE_PM_OPS	(&bcm_iproc_dte_pm_ops)
#else
#define BCM_IPROC_DTE_PM_OPS	NULL
#endif

static struct platform_driver bcm_iproc_dte_driver = {
	.driver = {
		.name = "iproc-dte",
		.pm = BCM_IPROC_DTE_PM_OPS,
		.of_match_table = bcm_iproc_dte_of_match,
	},
	.probe    = bcm_iproc_dte_probe,
	.remove   = bcm_iproc_dte_remove,
};
module_platform_driver(bcm_iproc_dte_driver);

MODULE_AUTHOR("Broadcom");
MODULE_DESCRIPTION("Broadcom iproc DTE Digital Timing Engine driver");
MODULE_LICENSE("GPL v2");
