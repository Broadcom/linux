/*
 * Copyright 2016 Broadcom
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License, version 2, as
 * published by the Free Software Foundation (the "GPL").
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License version 2 (GPLv2) for more details.
 *
 * You should have received a copy of the GNU General Public License
 * version 2 (GPLv2) along with this source code.
 */

/*
 * This driver implements the Broadcom DTE Digital Timing Engine Driver (DTE).
 * The DTE allows for hardware time stamping of network packets, audio/video
 * samples and/or GPIO inputs in a common adjustable time base.
 *
 * The DTE creates timestamps of hardware based events such as GPIO, I2S
 * signals for audio, etc. It provides a clock for 802.1AS / NCO timestamps for
 * network packets. It has up to 32 "clients" -- the hardware inputs into the
 * timestamping engine.
 *
 * Clients can be enabled at any time with timestamps being generated at varying
 * frequencies. As clients are enabled that generate timestamps at higher
 * frequencies, the isochronous interrupt rate must be increased so that
 * overflows in the the h/w and s/w FIFO's don't occur.
 *
 * The DTE timestamper creates timestamps based on the current clock time. When
 * an event on an input occurs, DTE stores the timestamp in a h/w FIFO. Each
 * client has a divider that can be set to control the rate that timestamps are
 * generated at by the timestamper which are adjustable at run time.
 *
 * The isochronous interrupt is used to pull the timestamps out of the h/w
 * FIFO and store them in s/w FIFO's until they are pulled out of that from
 * user space. Each client has it's own FIFO allowing user space and kernel
 * consumers to only get timestamps they are interested in.
 *
 * The kernel API provided enables clients to get timestamps using
 * dte_enable_timestamp(). A clients divider is set with
 * dte_set_client_divider(). The isochronous interrupt frequency - the rate at
 * which the ISR fires to pull timestamps from h/w to s/w FIFO is
 * dte_set_irq_interval().
 *
 * Timestamps generated by the timestamper for clients are polled for using
 * dte_get_timestamp().
 *
 * The clock is controlled with the remaining functions: dte_set_time(),
 * dte_get_time(), dte_adj_time(), dte_adj_freq(). These functions provide
 * the time base for the timestamper but also provide a clock that was
 * meant to be used later by an Ethernet driver for NCO.
 *
 * ioctls are defined in uapi/linux/bcm_iproc_dte.h for the user space API and
 * correspond to these kernel functions.
 */

#include <linux/bcm_iproc_dte.h>
#include <linux/cdev.h>
#include <linux/delay.h>
#include <linux/fs.h>
#include <linux/hw_random.h>
#include <linux/init.h>
#include <linux/interrupt.h>
#include <linux/io.h>
#include <linux/kernel.h>
#include <linux/kfifo.h>
#include <linux/module.h>
#include <linux/slab.h>
#include <linux/of_address.h>
#include <linux/of_platform.h>
#include <linux/platform_device.h>
#include <linux/poll.h>
#include <linux/printk.h>
#include <linux/timer.h>
#include <linux/uaccess.h>
#include <uapi/linux/bcm_dte.h>

#define DTE_SW_FIFO_SIZE                         64
#define DTE_HW_FIFO_SIZE                         16
#define DTE_MAX_DEVS                             1
#define DTE_DEVICE_NAME                          "dte"
#define DTE_DEFAULT_INTERVAL                     500000000
#define DTE_DIV_YES                              1
#define DTE_DIV_NO                               0
/*
 * if the interval is above 4s, we will start having
 * issues in the ISR as 32-bits can overflow in this
 * time.
 */
#define DTE_POLL_INTERVAL_MIN                    3000000000U /* 3s */
#define DTE_NCO_OVF_TIMEOUT_MS                   3600000 /* 1 hour */

/* Macro to create register codes */
#define IO_CODE_PAGE_SHIFT  16
#define IO_CODE_REG_MASK    0xffff

#define PRIMARY_IOPAGE   1
#define TRIGG_IOPAGE     2
#define NCO_IOPAGE       3

#define PRIMARY_IO_PAGE_MASK  (PRIMARY_IOPAGE << IO_CODE_PAGE_SHIFT)
#define TRIGG_IO_PAGE_MASK    (TRIGG_IOPAGE   << IO_CODE_PAGE_SHIFT)
#define NCO_IO_PAGE_MASK      (NCO_IOPAGE     << IO_CODE_PAGE_SHIFT)


/* DTE_CTRL_REG    Bit defs */
#define DTE_CTRL_REG__INTERRUPT                  16

/* DTE_LTS_CSR_REG   Bit defs */
#define DTE_LTS_CSR_REG__FIFO_EMPTY              4
#define DTE_LTS_CSR_REG__FIFO_OVERFLOW           3
#define DTE_LTS_CSR_REG__FIFO_UNDERFLOW          2

/* DTE_INTR_STATUS_REG  Bit defs */
#define DTE_INTR_STATUS_ISO_INTR_SHIFT           0
#define DTE_INTR_STATUS_ISO_INTR_MASK            0x1
#define DTE_INTR_STATUS_FIFO_LEVEL_INTR_SHIFT    1
#define DTE_INTR_STATUS_FIFO_LEVEL_INTR_MASK     0x7
#define DTE_INTR_STATUS_TIMEOUT_INTR_SHIFT       4
#define DTE_INTR_STATUS_TIMEOUT_INTR_MASK        0x1

/* DTE_INTR_MASK_REG   Bit defs */
#define ISO_INTR_MASK_SHIFT                      0

#define NCO_FREQ_ABS_MAX_ADJ_PPB                 50000000
#define DTE_FLOW_ERROR_MASK                      0xc
/*
 * There are 3 time registers in the DTE block;
 * NCO_OVERFLOW[7:0] (sum3)
 * NCO_TIME[31:0] (sum2)
 * NCO_LOW_TIME[31:0] (sum1).
 * These can be considered as a 72 bit overall timestamp[71:0]
 * in ns with a format of 44.28
 *
 * The DTE block runs at 125MHz, ie; every 8ns,
 * NCO_INC is added to the timestamp[71:0].
 * NCO_INC represents fractional ns in 4.28 format.
 *
 * The DTE client Timstamps have a resoultion of ns and is constructed
 * from the 28 LS bits of sum2 and 4 MS bits of sum1.
 *
 * Register            |     sum3    |          sum2     |         sum1       |
 *                     |7           0|31  28            0|31    28:27        0|
 * Timestamp[71:0]     |71                                      28:27        0|
 * NCO_INC[31:0]                                         |31    28:27        0|
 * DTE client TS[31:0]                    |31                  0|
 */

/* NCO nominal increment = 8ns DTE operates at 125 MHz */
#define NCO_INC_NOMINAL 0x80000000

struct bcm_iproc_dte_params {
	struct dte_reg_offset reg_info;
	u16 divider_size; /* in bytes. */
	u32 divider_max;
	u16 lts_start_index;
	u16 num_of_clients;
	struct dte_client_list cli_info[32];
};

enum {
	BCM_SOC_CYGNUS,
	BCM_SOC_STINGRAY,
	BCM_SOC_OMEGA,
	BCM_SOC_MAX
};

static const struct bcm_iproc_dte_params dte_soc_params[BCM_SOC_MAX] = {
	{
		/* Cygnus SoC */
		.reg_info = {
			.ctrl		= (0x600 | PRIMARY_IO_PAGE_MASK),
			.next_soi	= (0x610 | PRIMARY_IO_PAGE_MASK),
			.ilen		= (0x614 | PRIMARY_IO_PAGE_MASK),
			.lts_fifo	= (0x640 | PRIMARY_IO_PAGE_MASK),
			.lts_csr	= (0x644 | PRIMARY_IO_PAGE_MASK),

			.nco_low_time	= (0x650 | PRIMARY_IO_PAGE_MASK),
			.nco_time	= (0x654 | PRIMARY_IO_PAGE_MASK),
			.nco_overflow	= (0x658 | PRIMARY_IO_PAGE_MASK),
			.nco_inc	= (0x65c | PRIMARY_IO_PAGE_MASK),

			.lts_div	= (0x660 | PRIMARY_IO_PAGE_MASK),
			.lts_src_en	= (0x680 | PRIMARY_IO_PAGE_MASK),
			.intr_status	= (0x6a0 | PRIMARY_IO_PAGE_MASK),
			.intr_mask	= (0x6a4 | PRIMARY_IO_PAGE_MASK),

			.trigg_reg	= (0x000 | TRIGG_IO_PAGE_MASK),
		},
		.divider_size = 2,
		.divider_max = 0xffff,
		.lts_start_index = 4,
		.num_of_clients = 12,
		.cli_info = {
			/* client, divider_status */
			{"I2S[0] bit clock", DTE_DIV_YES},
			{"I2S[1] bit clock", DTE_DIV_YES},
			{"I2S[2] bit clock", DTE_DIV_YES},
			{"I2S[0] word clock", DTE_DIV_YES},
			{"I2S[1] word clock", DTE_DIV_YES},
			{"I2S[2] word clock", DTE_DIV_YES},
			{"CLLP of LCD", DTE_DIV_YES},
			{"CLFP of LCD", DTE_DIV_YES},
			{"GPIO_14", DTE_DIV_YES},
			{"GPIO_15", DTE_DIV_YES},
			{"GPIO_22", DTE_DIV_YES},
			{"ENET", DTE_DIV_NO},
		}
	},
	{
		/* Stingray SoC */
		.reg_info = {
			.ctrl		= (0x600 | PRIMARY_IO_PAGE_MASK),
			.next_soi	= (0x610 | PRIMARY_IO_PAGE_MASK),
			.ilen		= (0x614 | PRIMARY_IO_PAGE_MASK),
			.lts_fifo	= (0x640 | PRIMARY_IO_PAGE_MASK),
			.lts_csr	= (0x644 | PRIMARY_IO_PAGE_MASK),

			.nco_low_time	= (0x650 | PRIMARY_IO_PAGE_MASK),
			.nco_time	= (0x654 | PRIMARY_IO_PAGE_MASK),
			.nco_overflow	= (0x658 | PRIMARY_IO_PAGE_MASK),
			.nco_inc	= (0x65c | PRIMARY_IO_PAGE_MASK),

			.lts_div	= (0x660 | PRIMARY_IO_PAGE_MASK),
			.lts_src_en	= (0x680 | PRIMARY_IO_PAGE_MASK),
			.intr_status	= (0x6a0 | PRIMARY_IO_PAGE_MASK),
			.intr_mask	= (0x6a4 | PRIMARY_IO_PAGE_MASK),

			.trigg_reg	= (0x000 | TRIGG_IO_PAGE_MASK),
		},
		.divider_size = 2,
		.divider_max = 0xfff,
		.lts_start_index = 4,
		.num_of_clients = 8,
		.cli_info = {
			/* client, divider_status */
			{"I2S0_BITCLOCK", DTE_DIV_YES},
			{"I2S0_WORDCLOCK", DTE_DIV_YES},
			{"GPIO14", DTE_DIV_YES},
			{"GPIO15", DTE_DIV_YES},
			{"GPIO22", DTE_DIV_YES},
			{"GPIO23", DTE_DIV_YES},
			{"INTERVAL_GEN 0 (TSYNC)", DTE_DIV_YES},
			{"INTERVAL_GEN 1 (TSYNC)", DTE_DIV_YES},
		}
	},
	{
		/* Omega SoC */
		.reg_info = {
			.ctrl		= (0x00 | PRIMARY_IO_PAGE_MASK),
			.next_soi	= (0x10 | PRIMARY_IO_PAGE_MASK),
			.ilen		= (0x14 | PRIMARY_IO_PAGE_MASK),
			.lts_fifo	= (0x40 | PRIMARY_IO_PAGE_MASK),
			.lts_csr	= (0x44 | PRIMARY_IO_PAGE_MASK),

			.nco_low_time	= (0x00 | NCO_IO_PAGE_MASK),
			.nco_time	= (0x04 | NCO_IO_PAGE_MASK),
			.nco_overflow	= (0x08 | NCO_IO_PAGE_MASK),
			.nco_inc	= (0x0c | NCO_IO_PAGE_MASK),

			.lts_div	= (0x60 | PRIMARY_IO_PAGE_MASK),
			.lts_src_en	= (0xcc | PRIMARY_IO_PAGE_MASK),
			.intr_status	= (0xd4 | PRIMARY_IO_PAGE_MASK),
			.intr_mask	= (0xd8 | PRIMARY_IO_PAGE_MASK),

			.trigg_reg	= (0x000 | TRIGG_IO_PAGE_MASK),
		},
		.divider_size = 2,
		.divider_max = 0xffffffff,
		.lts_start_index = 4,
		.num_of_clients = 22,
		.cli_info = {
			/* client, divider_status */
			{"I2S[0] bit clock", DTE_DIV_YES},
			{"I2S[1] bit clock", DTE_DIV_YES},
			{"I2S[2] bit clock", DTE_DIV_YES},
			{"I2S[0] frame clock", DTE_DIV_YES},
			{"I2S[1] frame clock", DTE_DIV_YES},
			{"I2S[2] frame clock", DTE_DIV_YES},
			{"GPIO0", DTE_DIV_YES},
			{"GPIO1", DTE_DIV_YES},
			{"GPIO2", DTE_DIV_YES},
			{"GPIO3", DTE_DIV_YES},
			{"GPIO4", DTE_DIV_YES},
			{"P1588 SYN OUT", DTE_DIV_YES},
			{"HBR bit clock", DTE_DIV_YES},
			{"HBR frame clock", DTE_DIV_YES},
			{"GPIO5", DTE_DIV_YES},
			{"GPIO6", DTE_DIV_YES},
			{"GPIO7", DTE_DIV_YES},
			{"SPDIF_OUT Frame Select", DTE_DIV_YES},
			{"SPDIF_IN Frame Select", DTE_DIV_YES},
			{"GENPLL_0 Divided Clock", DTE_DIV_YES},
			{"GENPLL_1 Divided Clock", DTE_DIV_YES},
			{"GENPLL_2 Divided Clock", DTE_DIV_YES},
		}
	}
};

static irqreturn_t bcm_iproc_dte_isr_threaded(int irq, void *drv_ctx);
static void dte_nco_ovf_tmr(struct timer_list *t);

static int dte_ioread(struct bcm_dte *iproc_dte, u32 code, u32 *val)
{
	u32 offset, io_page;

	offset = code & IO_CODE_REG_MASK;
	io_page = code >> IO_CODE_PAGE_SHIFT;

	switch (io_page) {
	case PRIMARY_IOPAGE:
		*val = readl(iproc_dte->audioeav_io + offset);
		break;
	case TRIGG_IOPAGE:
		*val = readl(iproc_dte->trigg_io + offset);
		break;
	case NCO_IOPAGE:
		*val = readl(iproc_dte->nco_io + offset);
		break;
	default:
		return -EINVAL;
	}

	return 0;
}

static int dte_iowrite(struct bcm_dte *iproc_dte, u32 code, u32 val)
{
	u32 offset, io_page;

	offset = code & IO_CODE_REG_MASK;
	io_page = code >> IO_CODE_PAGE_SHIFT;

	switch (io_page) {
	case PRIMARY_IOPAGE:
		writel(val, iproc_dte->audioeav_io + offset);
		break;
	case TRIGG_IOPAGE:
		writel(val, iproc_dte->trigg_io + offset);
		break;
	case NCO_IOPAGE:
		writel(val, iproc_dte->nco_io + offset);
		break;
	default:
		return -EINVAL;
	}

	return 0;
}

static int dte_read_nco_time(struct bcm_dte *iproc_dte,
	uint64_t *nco_time, uint32_t *ts_ovf)
{
	uint32_t sum1;
	uint32_t sum2;
	uint32_t sum3;

	if ((!iproc_dte) || (!nco_time) || (!ts_ovf))
		return -EINVAL;

	*nco_time = 0;
	*ts_ovf = 0;

	/* Read Timers */
	dte_ioread(iproc_dte, iproc_dte->reg_code.nco_low_time, &sum1);
	dte_ioread(iproc_dte, iproc_dte->reg_code.nco_time, &sum2);
	dte_ioread(iproc_dte, iproc_dte->reg_code.nco_overflow, &sum3);

/*
 * Register            |     sum3    |          sum2     |         sum1       |
 *                     |7           0|31  28            0|31    28:27        0|
 * Timestamp[71:0]     |71                                      28:27        0|

 */

	/* Current time in ns */
	*nco_time = (((uint64_t)(sum3 & 0xff) << 36) |
		((uint64_t)sum2 << 4) |
		(uint64_t)((sum1 >> 28) & 0xf));

	/*
	 * Timestamp overflow only includes the bottom 8 bits of sum3
	 * and the top 4 bits of sum2
	 * Units of 2^32 ns = 4.294967296 sec
	 */
	*ts_ovf = (*nco_time >> 32) & 0xfff;

	/*
	 * Check if Wrap around has occurred and not
	 * reflected in ts_ref.
	 * Full wrap around amount is 44bits in ns
	 * Precisely 17592.186044416 sec = ~4.887 hrs
	 */
	if (*ts_ovf < iproc_dte->timestamp_overflow_last)
		iproc_dte->ts_ref = timespec_add(iproc_dte->ts_ref,
			ns_to_timespec((uint64_t)1 << 44));

	iproc_dte->timestamp_overflow_last = *ts_ovf;

	return 0;

}

static void bcm_iproc_dte_enable(struct bcm_dte *iproc_dte, bool enable)
{
	int intr_mask;

	dte_ioread(iproc_dte, iproc_dte->reg_code.intr_mask, &intr_mask);
	if (enable)
		/* enable isochronous interrupt */
		intr_mask &= ~BIT(ISO_INTR_MASK_SHIFT);
	else
		/* disable isochronous interrupt */
		intr_mask |= BIT(ISO_INTR_MASK_SHIFT);

	dte_iowrite(iproc_dte, iproc_dte->reg_code.intr_mask, intr_mask);
}

static int dte_enable_timestamp(struct bcm_dte *iproc_dte,
				unsigned int client, bool enable)
{
	int src_ena;

	if (!iproc_dte)
		return -EINVAL;

	if (client >= iproc_dte->num_of_clients)
		return -EINVAL;

	spin_lock_bh(&iproc_dte->lock);

	dte_ioread(iproc_dte, iproc_dte->reg_code.lts_src_en, &src_ena);
	if (enable)
		src_ena |= BIT(iproc_dte->dte_cli[client].lts_index);
	else
		src_ena &= ~BIT(iproc_dte->dte_cli[client].lts_index);

	dte_iowrite(iproc_dte, iproc_dte->reg_code.lts_src_en, src_ena);

	spin_unlock_bh(&iproc_dte->lock);

	return 0;
}

static void dte_set_ts_trigg_edge(struct bcm_dte *iproc_dte,
				  uint32_t client, bool both_edge)
{
	uint32_t val;

	if (!iproc_dte)
		return;

	if ((!iproc_dte->trigg_io) ||
		(client >= iproc_dte->num_of_clients))
		return;

	dte_ioread(iproc_dte, iproc_dte->reg_code.trigg_reg, &val);
	if (both_edge)
		val |= BIT(client);
	else
		val &= ~BIT(client);

	dte_iowrite(iproc_dte, iproc_dte->reg_code.trigg_reg, val);
}

static int dte_set_client_divider(struct bcm_dte *iproc_dte,
				  unsigned int client,
				  uint32_t divider)
{
	int lts_div;

	if (!iproc_dte)
		return -EINVAL;

	if (client >= iproc_dte->num_of_clients)
		return -EINVAL;

	/* Divider not supported */
	if (!iproc_dte->dte_cli[client].div_status)
		return 0;

	/* Check for maximum divider size */
	if (divider > iproc_dte->max_client_div)
		return -EINVAL;

	spin_lock_bh(&iproc_dte->lock);

	dte_ioread(iproc_dte, iproc_dte->dte_cli[client].reg_code, &lts_div);
	lts_div &= ~(iproc_dte->max_client_div <<
		     iproc_dte->dte_cli[client].shift);
	lts_div |= (divider << iproc_dte->dte_cli[client].shift);
	dte_iowrite(iproc_dte, iproc_dte->dte_cli[client].reg_code, lts_div);

	spin_unlock_bh(&iproc_dte->lock);

	return 0;
}

static void dte_hw_fifo_tmr(struct timer_list *t)
{
	struct bcm_dte *iproc_dte = from_timer(iproc_dte, t, fifo_timer);

	bcm_iproc_dte_isr_threaded(0, iproc_dte);

	/* reset timer */
	mod_timer(&iproc_dte->fifo_timer, (jiffies +
		nsecs_to_jiffies((iproc_dte->irq_interval_ns))));
}

static void dte_init_nco_ovf_tmr(struct bcm_dte *iproc_dte)
{
	timer_setup(&iproc_dte->ovf_timer, dte_nco_ovf_tmr, 0);
}

static void dte_start_nco_ovf_tmr(struct bcm_dte *iproc_dte)
{
	iproc_dte->ovf_timer.expires =
		jiffies + msecs_to_jiffies(DTE_NCO_OVF_TIMEOUT_MS);
	add_timer(&iproc_dte->ovf_timer);
}

static void dte_stop_nco_ovf_tmr(struct bcm_dte *iproc_dte)
{
	del_timer_sync(&iproc_dte->ovf_timer);
}

static void dte_disable_nco(struct bcm_dte *iproc_dte)
{
	/* Disable NCO Increment */
	dte_iowrite(iproc_dte, iproc_dte->reg_code.nco_inc, 0);

	/* Reset Timers */
	dte_iowrite(iproc_dte, iproc_dte->reg_code.nco_low_time, 0);
	dte_iowrite(iproc_dte, iproc_dte->reg_code.nco_time, 0);
	dte_iowrite(iproc_dte, iproc_dte->reg_code.nco_overflow, 0);

	/* Initialize last overflow value to track wrap condition */
	iproc_dte->timestamp_overflow_last = 0;
}

static void dte_enable_nco(struct bcm_dte *iproc_dte,
	uint32_t nco_incr)
{
	/* start the nco if it is stopped */
	if (!nco_incr)
		nco_incr = NCO_INC_NOMINAL;

	/* enable NCO Increment */
	dte_iowrite(iproc_dte, iproc_dte->reg_code.nco_inc, nco_incr);
}

static void dte_en_nco_if_stopped(struct bcm_dte *iproc_dte)
{
	uint32_t nco_incr;

	spin_lock_bh(&iproc_dte->lock);
	dte_ioread(iproc_dte, iproc_dte->reg_code.nco_inc, &nco_incr);

	if (!nco_incr)
		dte_enable_nco(iproc_dte, nco_incr);
	spin_unlock_bh(&iproc_dte->lock);
}

static int dte_set_irq_interval(struct bcm_dte *iproc_dte,
	uint32_t nanosec)
{
	int next_soi;
	int current_time;

	if (!iproc_dte)
		return -EINVAL;

	if (iproc_dte->irq < 0) {
		/* if IIG irq is not specified run the soft-timer mode */
		if (!nanosec)
			del_timer_sync(&iproc_dte->fifo_timer);
		else {
			timer_setup(&iproc_dte->fifo_timer, dte_hw_fifo_tmr, 0);
			iproc_dte->fifo_timer.expires =
				jiffies + nsecs_to_jiffies((nanosec));
			add_timer(&iproc_dte->fifo_timer);
		}

		return 0;
	}

	spin_lock_bh(&iproc_dte->lock);

	/*
	 * To ensure proper operation of the isochronous time interval
	 * generation (ITG) timing pulse requires programming of
	 * 1) Next Start of Interrupt Time (ns) (NEXT_SOI)
	 * 2) Interval Length (ns) (ILEN)
	 * The block first compares the value of the NEXT_SOI with
	 * that of the 29-bit value of time DTE_NCO_TIME_REG_BASE
	 * that has been left-shifted by 4 or multiplied by 16 for
	 * generating the first interrupt.  Thereafter upon completion
	 * of every ILEN number of nano-seconds it generates an ITG
	 * interrupt and the NEXT_SOI register is auto-incremented by ILEN
	 */

	/* Get the current time (sum2) (units of 16ns) */
	dte_ioread(iproc_dte, iproc_dte->reg_code.nco_time, &current_time);

	/*
	 * Set the Start of Next Interval (units of ns) to trigger on next
	 * interval
	 */
	next_soi = (current_time << 4) + (nanosec);
	dte_iowrite(iproc_dte, iproc_dte->reg_code.next_soi, next_soi);

	/* configure interval length (units of ns) */
	dte_iowrite(iproc_dte, iproc_dte->reg_code.ilen, nanosec);

	if (nanosec)
		/* enable isochronous interrupt */
		bcm_iproc_dte_enable(iproc_dte, true);
	else
		/* disable isochronous interrupt */
		bcm_iproc_dte_enable(iproc_dte, false);

	spin_unlock_bh(&iproc_dte->lock);

	if (!nanosec)
		/* make sure the interrupt handler isn't running */
		synchronize_irq(iproc_dte->irq);

	return 0;
}

static int dte_get_timestamp(struct bcm_dte *iproc_dte,
			     unsigned int client, struct timespec *ts)
{

	if (!iproc_dte)
		return -EINVAL;

	if (client >= iproc_dte->num_of_clients)
		return -EINVAL;

	if (kfifo_out(
		&iproc_dte->recv_fifo[client],
		ts, sizeof(struct timespec)) == 0)
		return -EPERM;

	return 0;
}

static int dte_set_time(struct bcm_dte *iproc_dte, struct timespec *ts)
{
	uint32_t nco_incr;

	if (!iproc_dte)
		return -EINVAL;

	spin_lock_bh(&iproc_dte->lock);
	dte_ioread(iproc_dte, iproc_dte->reg_code.nco_inc, &nco_incr);
	dte_disable_nco(iproc_dte);
	/* Initialize Reference timespec */
	iproc_dte->ts_ref = *ts;
	dte_enable_nco(iproc_dte, nco_incr);
	spin_unlock_bh(&iproc_dte->lock);

	return 0;
}

static int dte_get_time(struct bcm_dte *iproc_dte,
			struct timespec *ts)
{
	int rc;
	uint32_t ts_ovf;
	uint64_t ns;

	if (!iproc_dte)
		return -EINVAL;

	spin_lock_bh(&iproc_dte->lock);
	rc = dte_read_nco_time(iproc_dte, &ns, &ts_ovf);
	spin_unlock_bh(&iproc_dte->lock);

	/* Add the current time to the reference time */
	*ts = timespec_add(iproc_dte->ts_ref, ns_to_timespec(ns));

	return rc;
}

static int dte_adj_time(struct bcm_dte *iproc_dte, int64_t delta)
{
	struct timespec ts_delta;

	if (!iproc_dte)
		return -EINVAL;

	ts_delta = ns_to_timespec(delta);

	spin_lock_bh(&iproc_dte->lock);

	/* Update Reference timespec */
	iproc_dte->ts_ref = timespec_add(iproc_dte->ts_ref, ts_delta);

	spin_unlock_bh(&iproc_dte->lock);

	return 0;
}

static int dte_adj_freq(struct bcm_dte *iproc_dte, int32_t ppb)
{
	uint32_t nco_incr;

	if (!iproc_dte)
		return -EINVAL;

	if (abs(ppb) > NCO_FREQ_ABS_MAX_ADJ_PPB) {
		dev_info(&iproc_dte->pdev->dev,
			"freq ppb adj too big\n");
		return 0;
	}

	/* 125MHz with 3.29 reg cfg */
	if (ppb < 0)
		nco_incr = NCO_INC_NOMINAL -
			(u32)(div64_u64((((u64)abs(ppb) * BIT(28)) +
				62500000ULL), 125000000ULL));
	else
		nco_incr = NCO_INC_NOMINAL +
			(u32)(div64_u64((((u64)abs(ppb) * BIT(28)) +
				62500000ULL), 125000000ULL));

	spin_lock_bh(&iproc_dte->lock);

	/* Update NCO Increment */
	dte_iowrite(iproc_dte, iproc_dte->reg_code.nco_inc, nco_incr);

	spin_unlock_bh(&iproc_dte->lock);

	return 0;
}

static int dte_get_freq_adj(struct bcm_dte *iproc_dte, int32_t *ppb)
{
	uint32_t nco_incr;

	if ((!iproc_dte) || (!ppb))
		return -EINVAL;

	spin_lock_bh(&iproc_dte->lock);
	dte_ioread(iproc_dte, iproc_dte->reg_code.nco_inc, &nco_incr);
	spin_unlock_bh(&iproc_dte->lock);

	/* Calculate the ppb adjustment from the NCO value */
	if (nco_incr < NCO_INC_NOMINAL)
		*ppb = -1 * (div64_u64(((u64)(NCO_INC_NOMINAL - nco_incr) *
			125000000ULL) + 0x8000000, (u64)BIT(28)));
	else
		*ppb = div64_u64(((u64)(nco_incr - NCO_INC_NOMINAL) *
			125000000ULL) + 0x8000000, (u64)BIT(28));

	return 0;
}

static void dte_nco_ovf_tmr(struct timer_list *t)
{
	struct bcm_dte *iproc_dte = from_timer(iproc_dte, t, ovf_timer);
	uint64_t nco_time;
	uint32_t ts_ovf;

	/* handle nco overflow */
	spin_lock_bh(&iproc_dte->lock);
	dte_read_nco_time(iproc_dte, &nco_time, &ts_ovf);
	spin_unlock_bh(&iproc_dte->lock);

	/* reset timer */
	mod_timer(&iproc_dte->ovf_timer, (jiffies +
		msecs_to_jiffies(DTE_NCO_OVF_TIMEOUT_MS)));
}

static void dte_update_user(struct bcm_dte *iproc_dte,
	unsigned int client,
	struct file *fp,
	bool add)
{
	if (add) {
		if (fp)
			iproc_dte->user[client].fp = fp;
		else
			iproc_dte->user[client].internal_user = true;

		iproc_dte->usr_cnt++;
	} else {
		iproc_dte->user[client].fp = NULL;
		iproc_dte->user[client].internal_user = false;
		iproc_dte->usr_cnt--;
	}
}

static void dte_disable_all_clients(struct bcm_dte *iproc_dte)
{
	int i;

	/* Disable all clients */
	for (i = 0; i < iproc_dte->num_of_clients; i++) {
		dte_enable_timestamp(iproc_dte, i, false);
		dte_set_client_divider(iproc_dte, i, 0);
	}

	dte_set_irq_interval(iproc_dte, 0);

	memset(&iproc_dte->user, 0, sizeof(struct dte_user_info));
	iproc_dte->usr_cnt = 0;
}

static int dte_enable_ts(struct bcm_dte *iproc_dte,
			 unsigned int client,
			 bool enable,
			 uint32_t divider,
			 bool both_edge,
			 struct file *fp)
{
	int rc = 0;
	int idx;

	if ((!iproc_dte) || (client >= iproc_dte->num_of_clients))
		return -EINVAL;

	mutex_lock(&iproc_dte->en_ts_lock);

	if (enable) {
		/* check if client is in use */
		if ((iproc_dte->user[client].fp) ||
			(iproc_dte->user[client].internal_user)) {
			rc = -EBUSY;
			goto en_ts_unlock_exit;
		}

		/* single client per fileptr */
		for (idx = 0; idx < iproc_dte->num_of_clients; idx++) {
			if (iproc_dte->user[idx].fp == fp) {
				dev_err(&iproc_dte->pdev->dev,
					"Error: file ptr already registred with client(%d)\n",
					idx);
				rc = -EBUSY;
				goto en_ts_unlock_exit;
			}
		}

		if (!iproc_dte->usr_cnt) {
			/* start DTE NCO if it is not running */
			dte_en_nco_if_stopped(iproc_dte);

			/*
			 * IRQ Interval needs to be set only
			 * once (when enabling first client)
			 */
			rc = dte_set_irq_interval(iproc_dte,
					iproc_dte->irq_interval_ns);
			if (rc) {
				dev_err(&iproc_dte->pdev->dev,
					"Failed to set IRQ interval\n");
				goto en_ts_unlock_exit;
			}
		}

		/* clear the clients fifo */
		kfifo_reset(&iproc_dte->recv_fifo[client]);

		rc = dte_set_client_divider(iproc_dte, client, divider);
		if (rc)
			goto dte_ts_disable_irq;

		dte_set_ts_trigg_edge(iproc_dte, client, both_edge);

		rc = dte_enable_timestamp(iproc_dte, client, enable);
		if (rc) {
			goto dte_ts_disable_divider;
		} else {
			/* Add client */
			dte_update_user(iproc_dte, client, fp, enable);
			goto en_ts_unlock_exit;
		}
	} else {
		if ((iproc_dte->user[client].fp) ||
			(iproc_dte->user[client].internal_user)) {
			dte_update_user(iproc_dte, client, fp, false);
		} else {
			/* Client is already disabled */
			rc = -EINVAL;
			goto en_ts_unlock_exit;
		}
	}

dte_ts_disable_divider:
	/* Check if anyone is using the client */
	rc |= dte_enable_timestamp(iproc_dte, client, false);
	rc |= dte_set_client_divider(iproc_dte, client, 0);

dte_ts_disable_irq:
	/* Disable DTE irq if there are no more users */
	if (!iproc_dte->usr_cnt)
		rc |= dte_set_irq_interval(iproc_dte, 0);

en_ts_unlock_exit:
	mutex_unlock(&iproc_dte->en_ts_lock);

	return rc;
}

static int dte_open(struct inode *pnode, struct file *fp)
{
	/* look up device info for this device file */
	struct bcm_dte *iproc_dte = container_of(pnode->i_cdev,
			struct bcm_dte, dte_cdev);

	fp->private_data = iproc_dte;

	return 0;
}

static void dte_display_drv_info(struct bcm_dte *iproc_dte)
{
	int i;
	int32_t ppb;

	dev_info(&iproc_dte->pdev->dev,
		"DTE Driver: %s\n",
		iproc_dte->pdev->name);
	dev_info(&iproc_dte->pdev->dev,
		" Fifo Mode: %s, interval: %dns\n",
		((iproc_dte->irq > 0) ? "irq" : "soft-timer"),
		iproc_dte->irq_interval_ns);

	dev_info(&iproc_dte->pdev->dev,
		" hw fifo errors: uf=%d, of=%d\n",
		iproc_dte->fifouf,
		iproc_dte->fifoof);

	dev_info(&iproc_dte->pdev->dev,
		" Active Clients: %d\n",
		iproc_dte->usr_cnt);

	for (i = 0; i < iproc_dte->num_of_clients; i++) {
		if ((iproc_dte->user[i].fp) ||
			(iproc_dte->user[i].internal_user))
			dev_info(&iproc_dte->pdev->dev,
				"    %2d (%s)\n",
				i,
				((iproc_dte->user[i].internal_user) ?
					"kernel-drv" : "user-space"));
	}

	dte_get_freq_adj(iproc_dte, &ppb);

	dev_info(&iproc_dte->pdev->dev,
		" Freq Adj Applied: %i ppb\n",
		ppb);
}

static unsigned int dte_poll(struct file *fp, poll_table *wait)
{
	struct bcm_dte *iproc_dte = fp->private_data;
	int idx;

	for (idx = 0; idx < iproc_dte->num_of_clients; idx++)
		if (iproc_dte->user[idx].fp == fp)
			break;

	if (idx == iproc_dte->num_of_clients)
		return POLLERR;

	poll_wait(fp, &iproc_dte->user[idx].ts_wait_queue, wait);
	return kfifo_is_empty(&iproc_dte->recv_fifo[idx]) ?
					0 : POLLIN | POLLRDNORM;
}

void dte_get_client_list(struct bcm_dte *iproc_dte,
	struct dte_client_list *cli_list)
{
	int i;

	for (i = 0; i < iproc_dte->num_of_clients; i++) {
		strncpy(cli_list[i].name, iproc_dte->dte_cli[i].name, 25);
		cli_list[i].div_status = iproc_dte->dte_cli[i].div_status;
	}
}

static long dte_ioctl(struct file *filep,
		      unsigned int cmd,
		      unsigned long arg)
{
	int ret = 0;
	struct dte_client_data dte_client_info;
	struct dte_timestamp dte_timestamp;
	struct timespec ts;
	int64_t delta;
	int32_t ppb;
	struct bcm_dte *iproc_dte = filep->private_data;
	struct dte_client_list cli_list[iproc_dte->num_of_clients];

	mutex_lock(&iproc_dte->mutex);
	switch (cmd) {
	case DTE_IOCTL_GET_TIMESTAMP:
		if (copy_from_user(&dte_timestamp, (struct dte_timestamp *)arg,
				sizeof(struct dte_timestamp))) {
			ret = -EACCES;
			goto err_out;
		}
		if (dte_get_timestamp(iproc_dte,
				dte_timestamp.client,
				&dte_timestamp.ts)) {
			ret = -EPERM;
			goto err_out;
		}
		if (copy_to_user((struct dte_timestamp *)arg, &dte_timestamp,
				sizeof(struct dte_timestamp)))
			ret = -EACCES;
		break;

	case DTE_IOCTL_SET_TIME:
		if (copy_from_user(&ts, (struct timespec *)arg,
				sizeof(struct timespec))) {
			ret = -EACCES;
			goto err_out;
		}
		if (dte_set_time(iproc_dte, &ts))
			ret = -EPERM;
		break;

	case DTE_IOCTL_GET_TIME:
		if (dte_get_time(iproc_dte, &ts))
			ret = -EPERM;
		if (copy_to_user((struct timespec *)arg, &ts,
				sizeof(struct timespec)))
			ret = -EACCES;
		break;

	case DTE_IOCTL_ADJ_TIME:
		if (copy_from_user(&delta, (int64_t *)arg,
				sizeof(int64_t))) {
			ret = -EACCES;
			goto err_out;
		}
		if (dte_adj_time(iproc_dte, delta))
			ret = -EPERM;
		break;

	case DTE_IOCTL_ADJ_FREQ:
		if (copy_from_user(&ppb, (int32_t *)arg,
				sizeof(int32_t))) {
			ret = -EACCES;
			goto err_out;
		}
		if (dte_adj_freq(iproc_dte, ppb))
			ret = -EPERM;
		break;

	case DTE_IOCTL_GET_FREQ_ADJ:
		ret = dte_get_freq_adj(iproc_dte, &ppb);
		if (!ret)
			if (copy_to_user((struct int32_t *)arg, &ppb,
					sizeof(int32_t)))
				ret = -EACCES;
		break;

	case DTE_IOCTL_ENABLE_CLIENT_TS:
		if (copy_from_user(&dte_client_info,
				   (struct dte_client_data *)arg,
				   sizeof(struct dte_client_data))) {
			ret = -EACCES;
			goto err_out;
		}

		if (dte_client_info.both_edge && !iproc_dte->trigg_io) {
			ret = -EPERM;
			goto err_out;
		}

		ret = dte_enable_ts(iproc_dte,
				    dte_client_info.client,
				    dte_client_info.enable,
				    dte_client_info.divider,
				    (dte_client_info.both_edge ? true : false),
				    filep);
		break;

	case DTE_IOCTL_DISPLAY_DRV_INF:
		dte_display_drv_info(iproc_dte);
		break;

	case DTE_IOCTL_GET_NUM_OF_CLIENT:
		if (copy_to_user((uint32_t *)arg,
				&iproc_dte->num_of_clients,
				sizeof(uint32_t)))
			ret = -EACCES;
		break;

	case DTE_IOCTL_GET_CLIENT_LIST:
		dte_get_client_list(iproc_dte, cli_list);
		if (copy_to_user((struct dte_client_list *)arg, cli_list,
				sizeof(struct dte_client_list) *
				iproc_dte->num_of_clients))
			ret = -EACCES;
		break;

	default:
		ret = -EINVAL;
		break;
	}

err_out:
	mutex_unlock(&iproc_dte->mutex);
	return ret;
}

int dte_release(struct inode *node, struct file *fp)
{
	struct bcm_dte *iproc_dte = fp->private_data;
	int i = 0;

	for (i = 0; i < iproc_dte->num_of_clients; i++)
		if (iproc_dte->user[i].fp == fp)
			dte_enable_ts(iproc_dte, i, false, 0, false, fp);

	return 0;
}

static const struct file_operations dte_cdev_fops = {
	.open           = dte_open,
	.poll           = dte_poll,
	.unlocked_ioctl = dte_ioctl,
	.release = dte_release,
};

static int dte_read_client_ts_fifo(struct bcm_dte *iproc_dte,
	uint32_t *clients, uint32_t *ts)
{
	uint32_t fifo_csr;
	int rc = 0;

	*clients = 0;
	*ts = 0;

	dte_ioread(iproc_dte, iproc_dte->reg_code.lts_csr, &fifo_csr);
	if (fifo_csr & BIT(DTE_LTS_CSR_REG__FIFO_EMPTY)) {
		if (fifo_csr & BIT(DTE_LTS_CSR_REG__FIFO_UNDERFLOW)) {
			iproc_dte->fifouf++;
			dev_err(&iproc_dte->pdev->dev,
				"fifouf = %d\n", iproc_dte->fifouf);
		}
		if (fifo_csr & BIT(DTE_LTS_CSR_REG__FIFO_OVERFLOW)) {
			iproc_dte->fifoof++;
			dev_err(&iproc_dte->pdev->dev,
				"fifoof =%d\n", iproc_dte->fifoof);
		}

		/* overflow/underflow error, reset fifo */
		if (fifo_csr & 0xc) {
			dte_iowrite(iproc_dte, iproc_dte->reg_code.lts_csr, 0);
			dev_err(&iproc_dte->pdev->dev, "Resetting HW FIFO\n");
		}

		rc = -ENODATA;
	} else {
		/* first event contains active clients */
		dte_ioread(iproc_dte, iproc_dte->reg_code.lts_fifo, clients);

		/* then timestamp */
		dte_ioread(iproc_dte, iproc_dte->reg_code.lts_fifo, ts);
	}

	return rc;
}

static irqreturn_t bcm_iproc_dte_isr_threaded(int irq, void *drv_ctx)
{
	uint32_t i = 0;
	uint32_t active_clients;
	int client;
	int inlen;
	struct bcm_dte *iproc_dte = (struct bcm_dte *)drv_ctx;
	uint32_t status;
	uint32_t client_ts_ns;
	uint64_t nco_time;
	uint32_t nco_ovf;
	struct timespec client_tstamp = {0, 0};

	/* clear interrupt bit */
	dte_iowrite(iproc_dte, iproc_dte->reg_code.ctrl,
		    BIT(DTE_CTRL_REG__INTERRUPT));

	/* clear all interrupts in status register */
	status = (DTE_INTR_STATUS_ISO_INTR_MASK <<
		DTE_INTR_STATUS_ISO_INTR_SHIFT) |
		(DTE_INTR_STATUS_FIFO_LEVEL_INTR_MASK <<
		DTE_INTR_STATUS_FIFO_LEVEL_INTR_SHIFT) |
		(DTE_INTR_STATUS_TIMEOUT_INTR_MASK <<
		DTE_INTR_STATUS_TIMEOUT_INTR_SHIFT);
	dte_iowrite(iproc_dte, iproc_dte->reg_code.intr_status, status);

	do {
		spin_lock(&iproc_dte->lock);
		/* get data from dte fifo */
		if (dte_read_client_ts_fifo(iproc_dte,
				&active_clients, &client_ts_ns)) {
			spin_unlock(&iproc_dte->lock);
			break;
		}

		dte_read_nco_time(iproc_dte, &nco_time, &nco_ovf);

		client_tstamp.tv_sec = iproc_dte->ts_ref.tv_sec;
		client_tstamp.tv_nsec = iproc_dte->ts_ref.tv_nsec;

		/*
		 * The client_ts is only 32bits. So we need the MSB
		 * 12-bits which is available in the current NCO time.
		 * But we need to account for overflows that
		 * happened between client_ts and the nco_time.
		 *
		 * The API should run fast enough (once every 4s) so
		 * that the below can catch the 32-bit overflows,
		 * which it typically does.
		 */
		if (((uint32_t)(nco_time & 0xffffffff)) <= client_ts_ns) {
			/* account for 44-bit overflow boundary */
			if (nco_ovf > 0) {
				nco_ovf--;
			} else {
				/* wrap around condition */
				nco_ovf = 0xfff;

				/*
				 * ts_ref nedds to be used to account for
				 * previous ovf's etc. to get the time to
				 * current value.
				 *
				 * dte_read_nco_time() adds overflow to
				 * ts_ref. This needs to be taken off
				 * from the ref time to get to the current
				 * time when the wrap around happens.
				 */
				client_tstamp = timespec_sub(
					iproc_dte->ts_ref,
					ns_to_timespec((uint64_t)1 << 44));
			}
		}

		/* add the client_ts + 12 MSB bits to the ts_ref value */
		client_tstamp = timespec_add(client_tstamp,
			ns_to_timespec(((uint64_t)client_ts_ns +
			((uint64_t)nco_ovf << 32))));

		spin_unlock(&iproc_dte->lock);

		/*
		 * The valid timestamp may be valid for more than one client
		 * Examine all the active clients and insert timestamp
		 * to the appropriate software fifo for each client asserted
		 * Clients[0:3] are unused.
		 * Shift down by 4 to zero index the first valid input client
		 */
		active_clients >>= 4;

		for_each_set_bit(client,
			(unsigned long *)&active_clients,
			iproc_dte->num_of_clients) {
			/* Insert full timestamps into software fifo */
			inlen = kfifo_in(
				&iproc_dte->recv_fifo[client],
				&client_tstamp,
				sizeof(struct timespec));

			if (inlen != sizeof(struct timespec)) {
				iproc_dte->kfifoof[client]++;
				dev_err(&iproc_dte->pdev->dev,
					"kfifoof[%d] = %d\n",
					client,
					iproc_dte->kfifoof[client]);
			}

			wake_up_interruptible(
				&iproc_dte->user[client].ts_wait_queue);
		}
	} while (++i < DTE_HW_FIFO_SIZE); /* at most get FIFO size */

	return IRQ_HANDLED;
}

static const struct of_device_id bcm_iproc_dte_of_match[] = {
	{ .compatible = "brcm,iproc-dte", },
	{},
};
MODULE_DEVICE_TABLE(of, bcm_iproc_dte_of_match);

static const struct of_device_id bcm_dte_soc_of_match[] = {
	{ .compatible = "brcm,cygnus-dte", .data = (void *)BCM_SOC_CYGNUS },
	{ .compatible = "brcm,stingray-dte", .data = (void *)BCM_SOC_STINGRAY },
	{ .compatible = "brcm,omega-dte", .data = (void *)BCM_SOC_OMEGA },
	{},
};
MODULE_DEVICE_TABLE(of, bcm_dte_soc_of_match);

static int bcm_iproc_dte_probe(struct platform_device *pdev)
{
	struct device *dev = &pdev->dev;
	struct resource *res;
	struct bcm_dte *iproc_dte;
	int ret = -ENOMEM;
	dev_t devt;
	struct device *retdev;
	struct class *dte_class;
	int client, divider;
	uint32_t lts_reg_code;
	int irq;
	const struct bcm_iproc_dte_params *dte_params;
	const struct of_device_id *of_id = NULL;

	of_id = of_match_node(bcm_dte_soc_of_match, dev->of_node);
	if (of_id) {
		dte_params = &dte_soc_params[(u32)(unsigned long)of_id->data];
	} else {
		dev_err(&pdev->dev,
			"%s soc not defined\n", __func__);
		return -EINVAL;
	}

	iproc_dte = devm_kzalloc(dev, sizeof(*iproc_dte), GFP_KERNEL);
	if (!iproc_dte)
		return -ENOMEM;

	mutex_init(&iproc_dte->mutex);
	mutex_init(&iproc_dte->en_ts_lock);

	/* Audio DTE memory mapped registers */
	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "dte_primary");
	if (!res) {
		dev_err(&pdev->dev, "dte_primary io mem not specified.");
		return -ENODEV;
	}
	iproc_dte->audioeav_io = devm_ioremap_resource(dev, res);
	if (IS_ERR(iproc_dte->audioeav_io)) {
		dev_err(&pdev->dev, "%s IO remap audioeav failed\n", __func__);
		return PTR_ERR(iproc_dte->audioeav_io);
	}

	if ((unsigned long)of_id->data == BCM_SOC_OMEGA) {
		/* Audio DTE NCO memory mapped registers */
		res = platform_get_resource_byname(pdev, IORESOURCE_MEM,
						   "dte_nco");
		if (!res) {
			dev_err(&pdev->dev, "dte_nco io mem not specified.");
			return -ENODEV;
		}

		iproc_dte->nco_io = devm_ioremap_resource(dev, res);
		if (IS_ERR(iproc_dte->nco_io)) {
			dev_err(&pdev->dev,
				"%s IO remap dte_nco io failed\n", __func__);
			return PTR_ERR(iproc_dte->nco_io);
		}
	}

	/* optional register to set DTE edge trigger */
	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "dte_trigg");
	if (!res) {
		dev_info(&pdev->dev, "optional dte_trigg io not specified.");
		iproc_dte->trigg_io = NULL;
	} else {
		iproc_dte->trigg_io = devm_ioremap_resource(dev, res);
		if (IS_ERR(iproc_dte->trigg_io))
			return PTR_ERR(iproc_dte->trigg_io);
	}

	spin_lock_init(&iproc_dte->lock);
	dte_disable_nco(iproc_dte);

	/* get interrupt */
	irq = platform_get_irq(pdev, 0);
	iproc_dte->irq = irq;
	if (irq < 0)
		dev_info(&pdev->dev, "irq not specified, running soft-timer mode\n");

	ret = of_property_read_u32(pdev->dev.of_node,
		"brcm,dte-interval-ns", &iproc_dte->irq_interval_ns);
	if (ret) {
		dev_info(&pdev->dev, "interval not specified, defaulting to %d\n",
			DTE_DEFAULT_INTERVAL);
		iproc_dte->irq_interval_ns = DTE_DEFAULT_INTERVAL;
	} else if (iproc_dte->irq_interval_ns > DTE_POLL_INTERVAL_MIN) {
		dev_info(&pdev->dev,
			"poll interval cannot be more than %d, chainging poll to min\n",
			DTE_POLL_INTERVAL_MIN);
		iproc_dte->irq_interval_ns = DTE_POLL_INTERVAL_MIN;
	}

	if (irq > 0) {
		ret = devm_request_threaded_irq(&pdev->dev, irq,
					NULL, bcm_iproc_dte_isr_threaded,
					IRQF_ONESHOT, pdev->name, pdev);
		if (ret) {
			dev_err(&pdev->dev, "request_irq error %d\n", ret);
			return ret;
		}
	}

	iproc_dte->num_of_clients = dte_params->num_of_clients;

	iproc_dte->dte_cli = devm_kzalloc(dev,
			sizeof(struct dte_client_mapping) *
			iproc_dte->num_of_clients, GFP_KERNEL);
	if (!iproc_dte->dte_cli)
		return -ENOMEM;

	iproc_dte->recv_fifo = devm_kzalloc(dev,
				sizeof(struct kfifo) *
				iproc_dte->num_of_clients, GFP_KERNEL);
	if (!iproc_dte->recv_fifo)
		return -ENOMEM;

	iproc_dte->kfifoof = devm_kzalloc(dev,
				sizeof(uint32_t) *
				iproc_dte->num_of_clients, GFP_KERNEL);
	if (!iproc_dte->kfifoof)
		return -ENOMEM;

	iproc_dte->user = devm_kzalloc(dev,
				sizeof(struct dte_user_info) *
				iproc_dte->num_of_clients, GFP_KERNEL);
	if (!iproc_dte->user)
		return -ENOMEM;

	divider = sizeof(u32) / dte_params->divider_size;

	/* save register offsets */
	memcpy(&iproc_dte->reg_code,
	       &dte_params->reg_info,
	       sizeof(struct dte_reg_offset));
	lts_reg_code = iproc_dte->reg_code.lts_div;

	iproc_dte->max_client_div = dte_params->divider_max;

	for (client = 0; client < iproc_dte->num_of_clients; client++) {
		struct dte_client_mapping *p_dte_cli;

		ret = kfifo_alloc(&iproc_dte->recv_fifo[client],
				DTE_SW_FIFO_SIZE * sizeof(struct timespec),
				GFP_KERNEL);
		if (ret) {
			dev_err(dev, "Failed kfifo alloc\n");
			goto err_free_kfifo;
		}
		p_dte_cli = &iproc_dte->dte_cli[client];

		p_dte_cli->client_index = client;
		p_dte_cli->name = (char *)dte_params->cli_info[client].name;
		p_dte_cli->div_status = dte_params->cli_info[client].div_status;
		p_dte_cli->lts_index = dte_params->lts_start_index + client;

		if ((unsigned long)of_id->data == BCM_SOC_OMEGA) {
			iproc_dte->dte_cli[client].reg_code = lts_reg_code;
			lts_reg_code += 4;
			iproc_dte->dte_cli[client].shift = 0;
		} else {
			if (divider == client) {
				lts_reg_code += 4;
				divider += dte_params->divider_size;
			}
			if ((divider - dte_params->divider_size == client)
			   || (client == 0)) {
				p_dte_cli->reg_code = lts_reg_code;
				p_dte_cli->shift = 0;
			} else {
				p_dte_cli->reg_code = lts_reg_code;
				p_dte_cli->shift = dte_params->divider_size * 8;
			}
		}

		init_waitqueue_head(&iproc_dte->user[client].ts_wait_queue);
	}

	/* create device */
	cdev_init(&iproc_dte->dte_cdev, &dte_cdev_fops);

	iproc_dte->pdev = pdev;

	/* create class for mdev auto create node /dev/dte */
	dte_class = class_create(THIS_MODULE, DTE_DEVICE_NAME);
	if (IS_ERR(dte_class)) {
		ret = PTR_ERR(dte_class);
		dev_err(&pdev->dev, "can't register static dte class\n");
		goto err_free_kfifo;
	}
	iproc_dte->dte_class = dte_class;

	ret = alloc_chrdev_region(&devt, 0, DTE_MAX_DEVS, DTE_DEVICE_NAME);
	if (ret) {
		dev_err(&pdev->dev,
			"%s Alloc char device region failed\n", __func__);
		goto err_class_destroy;
	}

	ret = cdev_add(&iproc_dte->dte_cdev, devt, 1);
	if (ret) {
		dev_err(dev, "Failed adding dte cdev file\n");
		goto err_unreg_chardev;
	}

	retdev = device_create(iproc_dte->dte_class, NULL,
			devt, NULL, DTE_DEVICE_NAME);
	if (IS_ERR(retdev)) {
		dev_err(&pdev->dev, "can't create dte device\n ");
		ret = PTR_ERR(retdev);
		goto err_cdev_delete;
	}

	iproc_dte->enable_ts = dte_enable_ts;
	iproc_dte->get_ts = dte_get_timestamp;
	iproc_dte->nco_set_time = dte_set_time;
	iproc_dte->nco_get_time = dte_get_time;
	iproc_dte->nco_adj_time = dte_adj_time;
	iproc_dte->nco_adj_freq = dte_adj_freq;
	iproc_dte->nco_get_freq_adj = dte_get_freq_adj;

	platform_set_drvdata(pdev, iproc_dte);
	iproc_dte->devt = devt;

	dte_init_nco_ovf_tmr(iproc_dte);
	dte_start_nco_ovf_tmr(iproc_dte);

	dev_info(dev, "DTE Initialized.\n");

	return 0;

err_cdev_delete:
	cdev_del(&iproc_dte->dte_cdev);
err_unreg_chardev:
	unregister_chrdev_region(devt, DTE_MAX_DEVS);
err_class_destroy:
	class_destroy(iproc_dte->dte_class);
err_free_kfifo:
	for (client = 0; client < iproc_dte->num_of_clients; client++)
		kfifo_free(&iproc_dte->recv_fifo[client]);
	return ret;
}

static int bcm_iproc_dte_remove(struct platform_device *pdev)
{
	int client;
	struct bcm_dte *iproc_dte = platform_get_drvdata(pdev);

	device_destroy(iproc_dte->dte_class, iproc_dte->devt);
	class_destroy(iproc_dte->dte_class);
	unregister_chrdev_region(iproc_dte->devt, DTE_MAX_DEVS);
	cdev_del(&iproc_dte->dte_cdev);

	dte_disable_nco(iproc_dte);
	dte_stop_nco_ovf_tmr(iproc_dte);

	/* Disable all clients */
	dte_disable_all_clients(iproc_dte);

	platform_set_drvdata(pdev, NULL);

	for (client = 0; client < iproc_dte->num_of_clients; client++)
		kfifo_free(&iproc_dte->recv_fifo[client]);

	return 0;
}

#ifdef CONFIG_PM_SLEEP
static int bcm_iproc_dte_suspend(struct device *dev)
{
	struct platform_device *pdev = to_platform_device(dev);
	struct bcm_dte *iproc_dte = platform_get_drvdata(pdev);

	dev_info(dev, "Suspending DTE driver\n");

	/* disable intr or timer */
	dte_set_irq_interval(iproc_dte, 0);

	if (iproc_dte->trigg_io)
		dte_ioread(iproc_dte, iproc_dte->reg_code.trigg_reg,
			   &iproc_dte->trigg_reg_susp_val);

	dte_ioread(iproc_dte, iproc_dte->reg_code.nco_inc,
			&iproc_dte->nco_susp_val);
	dte_disable_nco(iproc_dte);
	dte_stop_nco_ovf_tmr(iproc_dte);

	/* Store and disable all sources */
	dte_ioread(iproc_dte, iproc_dte->reg_code.lts_src_en,
		   &iproc_dte->src_ena);
	dte_iowrite(iproc_dte, iproc_dte->reg_code.lts_src_en, 0);

	return 0;
}

static int bcm_iproc_dte_resume(struct device *dev)
{
	struct platform_device *pdev = to_platform_device(dev);
	struct bcm_dte *iproc_dte = platform_get_drvdata(pdev);

	dev_info(dev, "Resuming DTE driver\n");

	dte_start_nco_ovf_tmr(iproc_dte);
	if ((iproc_dte->nco_susp_val) || (iproc_dte->usr_cnt))
		dte_enable_nco(iproc_dte, iproc_dte->nco_susp_val);

	if (iproc_dte->usr_cnt) {
		/* re-enable intr or timer */
		dte_set_irq_interval(iproc_dte, iproc_dte->irq_interval_ns);

		if (iproc_dte->trigg_io)
			dte_iowrite(iproc_dte, iproc_dte->reg_code.trigg_reg,
				    iproc_dte->trigg_reg_susp_val);

		/* Re-enable sources */
		dte_iowrite(iproc_dte, iproc_dte->reg_code.lts_src_en,
			    iproc_dte->src_ena);
	}

	return 0;
}

static const struct dev_pm_ops bcm_iproc_dte_pm_ops = {
	.suspend = bcm_iproc_dte_suspend,
	.resume = bcm_iproc_dte_resume
};

#define BCM_IPROC_DTE_PM_OPS	(&bcm_iproc_dte_pm_ops)
#else
#define BCM_IPROC_DTE_PM_OPS	NULL
#endif

static struct platform_driver bcm_iproc_dte_driver = {
	.driver = {
		.name = "iproc-dte",
		.pm = BCM_IPROC_DTE_PM_OPS,
		.of_match_table = bcm_iproc_dte_of_match,
	},
	.probe    = bcm_iproc_dte_probe,
	.remove   = bcm_iproc_dte_remove,
};
module_platform_driver(bcm_iproc_dte_driver);

MODULE_AUTHOR("Broadcom");
MODULE_DESCRIPTION("Broadcom iproc DTE Digital Timing Engine driver");
MODULE_LICENSE("GPL v2");
